# Chapter3-3 과제 명세서

## 📋 프로젝트 개요

게시판 관리 Admin 코드를 클린하게 정돈하고 FSD 아키텍처를 활용하여 개선하는 프로젝트입니다.

### 현재 코드의 문제점

1. 컴포넌트가 너무 크고 복잡함 (PostsManagerPage.tsx가 700줄 이상)
2. TypeScript를 사용하고 있지만 Type 처리가 부실함
3. 상태관리의 개념 없이 너무 많은 상태를 가지고 있음 (20개 이상의 useState)
4. useEffect 관리가 안되고 있음
5. 비동기 처리 로직이 복잡하게 구성되어 있음

### 개선 목표

1. TypeScript를 확실히 사용하여 코드의 이해와 리팩토링에 대한 안정성 확보
2. 컴포넌트에 단일 책임 원칙을 부여하여 작게 만들기
3. 적절한 관심사의 분리를 통한 폴더구조 만들기
4. FSD(Feature-Sliced Design) 적용

---

## 🎯 과제의 핵심 목표

이 과제는 단순히 코드를 리팩토링하는 것이 아니라, **현대적인 프론트엔드 개발의 핵심 개념과 실무 역량을 습득**하는 것을 목표로 합니다.

### 1. 아키텍처 설계 능력 향상
- **대규모 프로젝트 구조 설계**: 복잡한 코드베이스를 체계적으로 구조화하는 방법 학습
- **관심사의 분리**: UI, 비즈니스 로직, 데이터 페칭을 명확히 분리하는 능력 습득
- **확장 가능한 구조 설계**: 새로운 기능 추가 시 기존 코드에 미치는 영향을 최소화하는 구조 설계

### 2. 상태 관리 전문성 확보
- **클라이언트 상태 관리**: Context API, Zustand, Jotai 등을 활용한 효율적인 상태 관리
- **서버 상태 관리**: TanstackQuery를 통한 서버 상태와 클라이언트 상태의 명확한 분리
- **상태 관리 전략**: 언제 어떤 상태 관리 도구를 사용해야 하는지 판단하는 능력

### 3. 코드 품질 개선 역량
- **리팩토링 기법**: 레거시 코드를 점진적으로 개선하는 실전 경험
- **타입 안정성**: TypeScript를 활용한 런타임 에러 방지 및 개발 생산성 향상
- **코드 가독성**: 다른 개발자도 쉽게 이해할 수 있는 코드 작성 능력

### 4. 실무 개발 패턴 습득
- **FSD 아키텍처**: 업계에서 널리 사용되는 Feature-Sliced Design 패턴 이해 및 적용
- **함수형 프로그래밍**: 선언적이고 예측 가능한 코드 작성 방법
- **비동기 처리**: 복잡한 비동기 로직을 선언적으로 관리하는 방법

### 5. 문제 해결 능력 강화
- **기술 부채 해결**: 실제 프로젝트에서 마주치는 문제점을 체계적으로 해결
- **트레이드오프 분석**: 다양한 아키텍처 패턴의 장단점을 이해하고 프로젝트에 맞게 선택
- **점진적 개선**: 한 번에 모든 것을 바꾸지 않고 단계적으로 개선하는 방법 학습

---

## 💎 과제 완료 후 얻는 것

### 기술적 역량

#### 1. 프론트엔드 아키텍처 설계 능력
- ✅ 대규모 React 프로젝트를 체계적으로 구조화할 수 있는 능력
- ✅ FSD, Clean Architecture 등 다양한 아키텍처 패턴을 이해하고 적용할 수 있는 능력
- ✅ 프로젝트 요구사항에 맞는 최적의 폴더 구조를 설계할 수 있는 능력
- ✅ 확장 가능하고 유지보수하기 쉬운 코드베이스를 구축할 수 있는 능력

#### 2. 상태 관리 전문성
- ✅ 클라이언트 상태와 서버 상태를 구분하고 적절히 관리할 수 있는 능력
- ✅ Props Drilling 문제를 해결하고 효율적인 상태 전달 방법을 설계할 수 있는 능력
- ✅ TanstackQuery를 활용한 서버 상태 관리의 모범 사례를 이해하고 적용할 수 있는 능력
- ✅ 낙관적 업데이트, 캐싱 전략 등 고급 상태 관리 기법을 활용할 수 있는 능력

#### 3. TypeScript 활용 능력
- ✅ 엔티티 중심의 타입 설계 방법을 이해하고 적용할 수 있는 능력
- ✅ 타입 안정성을 통해 런타임 에러를 사전에 방지할 수 있는 능력
- ✅ 복잡한 타입을 설계하고 유지보수할 수 있는 능력

#### 4. 리팩토링 전문성
- ✅ 레거시 코드를 분석하고 개선점을 찾아내는 능력
- ✅ 점진적이고 안전한 리팩토링 방법을 습득
- ✅ 리팩토링 후에도 기능이 정상 동작함을 보장하는 능력

### 실무 역량

#### 5. 협업 및 소통 능력
- ✅ 코드 리뷰를 통해 다른 개발자와 효과적으로 소통할 수 있는 능력
- ✅ 아키텍처 결정을 문서화하고 팀원들에게 설명할 수 있는 능력
- ✅ 기술 부채를 식별하고 개선 방안을 제시할 수 있는 능력

#### 6. 문제 해결 능력
- ✅ 복잡한 문제를 작은 단위로 분해하여 해결할 수 있는 능력
- ✅ 다양한 기술 선택지의 트레이드오프를 분석하고 최적의 선택을 할 수 있는 능력
- ✅ 기술 문서를 읽고 새로운 기술을 빠르게 학습하고 적용할 수 있는 능력

#### 7. 코드 품질 관리
- ✅ 단일 책임 원칙, 관심사의 분리 등 SOLID 원칙을 실전에 적용할 수 있는 능력
- ✅ 재사용 가능하고 테스트하기 쉬운 코드를 작성할 수 있는 능력
- ✅ 코드 가독성과 유지보수성을 높이는 방법을 이해하고 적용할 수 있는 능력

### 포트폴리오 및 경력

#### 8. 실전 프로젝트 경험
- ✅ 실제 프로젝트에서 사용할 수 있는 아키텍처 패턴 적용 경험
- ✅ 레거시 코드 개선 프로젝트 경험 (포트폴리오로 활용 가능)
- ✅ 현대적인 프론트엔드 개발 스택 활용 경험

#### 9. 기술 스택 확장
- ✅ React 고급 패턴 및 최신 기능 활용 경험
- ✅ TanstackQuery, Zustand/Jotai 등 현대적인 상태 관리 라이브러리 활용 경험
- ✅ TypeScript를 활용한 타입 안전한 개발 경험

#### 10. 개발자로서의 성장
- ✅ 코드베이스의 복잡성을 관리하는 방법을 이해
- ✅ 확장 가능한 애플리케이션을 설계하는 사고방식 습득
- ✅ 실무에서 바로 적용 가능한 실전 역량 확보

### 학습 성과

#### 11. 개념적 이해
- ✅ **FSD 아키텍처**: 레이어 기반 구조 설계의 원리와 실전 적용 방법
- ✅ **상태 관리 철학**: 언제 전역 상태를 사용하고, 언제 로컬 상태를 사용해야 하는지 판단 기준
- ✅ **함수형 프로그래밍**: 선언적이고 예측 가능한 코드 작성의 이점
- ✅ **관심사의 분리**: 코드의 각 부분이 명확한 책임을 가지도록 구조화하는 방법

#### 12. 실전 적용 능력
- ✅ 새로운 프로젝트를 시작할 때 적절한 구조를 설계할 수 있는 능력
- ✅ 기존 프로젝트의 문제점을 파악하고 개선 방안을 제시할 수 있는 능력
- ✅ 팀 프로젝트에서 아키텍처 결정에 기여할 수 있는 능력

---

## 🚀 이 과제를 통해 달성하는 것

이 과제를 완료하면, 단순히 "코드를 작성할 수 있는" 개발자가 아니라, **"좋은 코드를 설계하고 작성할 수 있는"** 개발자로 성장할 수 있습니다.

### Before (과제 전)
- ❌ 700줄이 넘는 거대한 컴포넌트
- ❌ 20개 이상의 useState로 인한 복잡한 상태 관리
- ❌ 타입이 명확하지 않은 코드
- ❌ 비동기 로직이 복잡하게 얽혀있는 코드
- ❌ 재사용하기 어려운 구조

### After (과제 후)
- ✅ 작고 명확한 책임을 가진 컴포넌트들
- ✅ 체계적으로 관리되는 상태
- ✅ 타입 안전성이 보장되는 코드
- ✅ 선언적이고 예측 가능한 비동기 처리
- ✅ 재사용 가능하고 확장하기 쉬운 구조
- ✅ 새로운 기능 추가가 쉬운 아키텍처

### 최종 목표
**"자신보다 남들에게 모두에게 이해하기 쉬운 코드"**를 작성할 수 있는 개발자가 되는 것입니다. 이것이 바로 실무에서 가장 중요한 역량이며, 이 과제를 통해 그 역량을 기를 수 있습니다.

---

## 🎯 1단계: Basic 과제 - 전역상태관리와 FSD 폴더 구조 적용

### 목표
전역상태관리를 이용한 적절한 분리와 계층에 대한 이해를 통한 FSD 폴더 구조 적용하기

### 학습 내용
- 전역상태관리를 사용해서 상태를 분리하고 관리하는 방법에 대한 이해
- Context API, Jotai, Zustand 등 상태관리 라이브러리 사용하기
- FSD(Feature-Sliced Design)에 대한 이해
- FSD를 통한 관심사의 분리에 대한 이해
  - 단일책임과 역할이란 무엇인가?
  - 관심사를 하나만 가지고 있는가?
  - 어디에 무엇을 넣어야 하는가?

### 작업 순서

#### 1.1 프로젝트 구조 분석 및 계획 수립
- [ ] 현재 코드의 구조 파악
- [ ] FSD 아키텍처 학습 및 이해
- [ ] 리팩토링 계획 수립

#### 1.2 TypeScript 타입 정의
- [ ] Post 엔티티 타입 정의
- [ ] Comment 엔티티 타입 정의
- [ ] User 엔티티 타입 정의
- [ ] Tag 엔티티 타입 정의
- [ ] API 응답 타입 정의
- [ ] 상태 관리용 타입 정의

#### 1.3 FSD 폴더 구조 생성
```
src/
├── app/              # 앱 초기화 및 설정
│   ├── providers/    # 전역 프로바이더
│   └── router/       # 라우팅 설정
├── shared/           # 공통 코드
│   ├── ui/           # 공통 UI 컴포넌트
│   ├── lib/          # 공통 유틸리티
│   └── api/          # 공통 API 설정
├── entities/         # 비즈니스 엔티티
│   ├── post/
│   │   ├── model/    # Post 상태 관리
│   │   ├── ui/       # Post 관련 UI 컴포넌트
│   │   └── api/      # Post API 호출
│   ├── comment/
│   │   ├── model/
│   │   ├── ui/
│   │   └── api/
│   └── user/
│       ├── model/
│       ├── ui/
│       └── api/
├── features/         # 사용자 기능
│   ├── post-list/    # 게시물 목록 조회
│   │   ├── ui/
│   │   └── model/
│   ├── post-create/  # 게시물 생성
│   ├── post-edit/    # 게시물 수정
│   ├── post-delete/  # 게시물 삭제
│   ├── post-search/  # 게시물 검색
│   ├── comment-list/ # 댓글 목록 조회
│   ├── comment-create/ # 댓글 생성
│   └── comment-edit/ # 댓글 수정
├── widgets/          # 복합 UI 블록
│   ├── post-table/   # 게시물 테이블 위젯
│   └── post-detail/  # 게시물 상세 위젯
└── pages/            # 페이지 컴포넌트
    └── PostsManagerPage.tsx
```

#### 1.4 전역상태관리 도입
- [ ] 상태관리 라이브러리 선택 및 설치 (Context API / Jotai / Zustand)
- [ ] 전역 상태 스토어 생성
- [ ] Props Drilling 제거
- [ ] 상태 분리 및 관리

#### 1.5 Shared 레이어 구현
- [ ] 공통 UI 컴포넌트 분리 (Button, Card, Dialog, Input, Select, Table 등)
- [ ] 공통 유틸리티 함수 분리 (highlightText 등)
- [ ] 공통 API 설정 (axios 인스턴스, 인터셉터 등)

#### 1.6 Entities 레이어 구현
- [ ] Post 엔티티
  - [ ] model: Post 상태 관리 로직
  - [ ] ui: PostCard, PostItem 등 UI 컴포넌트
  - [ ] api: Post API 호출 함수
- [ ] Comment 엔티티
  - [ ] model: Comment 상태 관리 로직
  - [ ] ui: CommentItem 등 UI 컴포넌트
  - [ ] api: Comment API 호출 함수
- [ ] User 엔티티
  - [ ] model: User 상태 관리 로직
  - [ ] ui: UserAvatar, UserInfo 등 UI 컴포넌트
  - [ ] api: User API 호출 함수

#### 1.7 Features 레이어 구현
- [ ] post-list: 게시물 목록 조회 기능
- [ ] post-create: 게시물 생성 기능
- [ ] post-edit: 게시물 수정 기능
- [ ] post-delete: 게시물 삭제 기능
- [ ] post-search: 게시물 검색 기능
- [ ] post-filter: 게시물 필터링 기능 (태그, 정렬)
- [ ] comment-list: 댓글 목록 조회 기능
- [ ] comment-create: 댓글 생성 기능
- [ ] comment-edit: 댓글 수정 기능
- [ ] comment-delete: 댓글 삭제 기능

#### 1.8 Widgets 레이어 구현
- [ ] post-table: 게시물 테이블 위젯 (필터, 정렬, 페이지네이션 포함)
- [ ] post-detail: 게시물 상세 위젯 (댓글 목록 포함)

#### 1.9 컴포넌트 분리 및 리팩토링
- [ ] PostsManagerPage를 작은 컴포넌트로 분리
- [ ] 각 컴포넌트에 단일 책임 원칙 적용
- [ ] useEffect 최적화 및 정리

### 체크포인트
- [ ] 전역상태관리를 사용해서 상태를 분리하고 관리했나요?
- [ ] Props Drilling을 최소화했나요?
- [ ] shared 공통 컴포넌트를 분리했나요?
- [ ] shared 공통 로직을 분리했나요?
- [ ] entities를 중심으로 type을 정의하고 model을 분리했나요?
- [ ] entities를 중심으로 ui를 분리했나요?
- [ ] entities를 중심으로 api를 분리했나요?
- [ ] feature를 중심으로 사용자행동(이벤트 처리)를 분리했나요?
- [ ] feature를 중심으로 ui를 분리했나요?
- [ ] feature를 중심으로 api를 분리했나요?
- [ ] widget을 중심으로 데이터를 재사용가능한 형태로 분리했나요?

---

## 🚀 2단계: Advanced 과제 - TanstackQuery를 이용한 코드 개선

### 목표
서버상태관리 도구인 TanstackQuery를 이용하여 비동기코드를 선언적인 함수형 프로그래밍으로 작성하기

### 학습 내용
- TanstackQuery의 사용법에 대한 이해
- TanstackQuery를 이용한 비동기 코드 작성에 대한 이해
- 비동기 코드를 선언적인 함수형 프로그래밍으로 작성하는 방법에 대한 이해

### 작업 순서

#### 2.1 TanstackQuery 설치 및 설정
- [ ] @tanstack/react-query 설치
- [ ] QueryClient 설정
- [ ] QueryClientProvider 설정
- [ ] React Query Devtools 설정

#### 2.2 API 레이어 리팩토링
- [ ] 모든 API 호출을 TanstackQuery hooks로 변환
- [ ] useQuery를 사용한 데이터 조회 (게시물 목록, 댓글 목록, 태그 목록 등)
- [ ] useMutation을 사용한 데이터 변경 (생성, 수정, 삭제)
- [ ] 쿼리 키 전략 수립 및 적용

#### 2.3 쿼리 키 관리
- [ ] 쿼리 키 팩토리 패턴 적용
- [ ] 계층적 쿼리 키 구조 설계
- [ ] 쿼리 무효화 전략 수립

#### 2.4 낙관적 업데이트 구현
- [ ] 게시물 생성 시 낙관적 업데이트
- [ ] 게시물 수정 시 낙관적 업데이트
- [ ] 게시물 삭제 시 낙관적 업데이트
- [ ] 댓글 생성/수정/삭제 시 낙관적 업데이트
- [ ] 에러 발생 시 롤백 처리

#### 2.5 캐싱 및 리프레시 전략
- [ ] staleTime 설정
- [ ] cacheTime 설정
- [ ] refetchOnWindowFocus 설정
- [ ] refetchOnMount 설정
- [ ] 자동 리프레시 전략 구현

#### 2.6 에러 핸들링
- [ ] 전역 에러 핸들링 설정
- [ ] 개별 쿼리/뮤테이션 에러 핸들링
- [ ] 에러 UI 컴포넌트 구현

#### 2.7 로딩 상태 관리
- [ ] 로딩 상태 UI 개선
- [ ] Suspense와 함께 사용 (선택사항)
- [ ] Skeleton UI 구현

#### 2.8 기존 코드 정리
- [ ] fetch와 useState 제거
- [ ] useEffect를 통한 데이터 페칭 제거
- [ ] 수동 상태 관리 코드 제거

### 체크포인트
- [ ] 모든 API 호출이 TanStack Query의 useQuery와 useMutation으로 대체되었는가?
- [ ] 쿼리 키가 적절히 설정되었는가?
- [ ] fetch와 useState가 아닌 선언적인 함수형 프로그래밍이 적절히 적용되었는가?
- [ ] 캐싱과 리프레시 전략이 올바르게 구현되었는가?
- [ ] 낙관적인 업데이트가 적용되었는가?
- [ ] 에러 핸들링이 적절히 구현되었는가?
- [ ] 서버 상태와 클라이언트 상태가 명확히 분리되었는가?
- [ ] 코드가 간결하고 유지보수가 용이한 구조로 작성되었는가?
- [ ] TanStack Query의 Devtools가 정상적으로 작동하는가?

---

## 🎨 3단계: 최종 과제 - 자신만의 기능 중심 폴더 구조 만들기

### 목표
FSD를 적용해보고 나서 조금 더 현대적이면서도 기능 중심의 폴더 구조 만들기

### 작업 순서

#### 3.1 FSD 적용 경험 분석
- [ ] FSD 적용 과정에서의 장점 파악
- [ ] FSD 적용 과정에서의 불편함이나 개선점 파악
- [ ] 프로젝트 특성에 맞는 구조 고민

#### 3.2 대안 구조 설계
- [ ] 다른 아키텍처 패턴 조사 (Domain-Driven Design, Clean Architecture 등)
- [ ] 프로젝트 요구사항에 맞는 구조 설계
- [ ] 계층 간 의존성 규칙 수립

#### 3.3 새로운 구조로 마이그레이션
- [ ] 새로운 폴더 구조 생성
- [ ] 기존 코드를 새로운 구조로 이동
- [ ] import 경로 수정
- [ ] 의존성 규칙 준수 확인

#### 3.4 문서화
- [ ] 새로운 구조의 설계 의도 문서화
- [ ] 각 레이어의 역할과 책임 명시
- [ ] 파일 배치 가이드라인 작성
- [ ] 예시 코드 작성

### 고려사항
1. 자신만의 기능 중심의 폴더라고 했지만, 그 모습이 상당히 유니크하고 독창적이지는 않을 거에요. 아마 적절한 모범사례의 조합으로 수렴될 거에요.
2. 그리고 그게 잘하는 거에요. 좋은 코드는? 자신보다 남들에게 모두에게 이해하기 쉬운 코드니까요.

---

## 📝 작업 가이드

### 개발 환경 설정
1. 의존성 설치: `pnpm install`
2. 개발 서버 실행: `pnpm dev`
3. 빌드: `pnpm build`
4. 린트: `pnpm lint`

### 코드 작성 원칙
1. **단일 책임 원칙**: 각 컴포넌트와 함수는 하나의 책임만 가져야 합니다.
2. **관심사의 분리**: UI, 비즈니스 로직, 데이터 페칭을 분리합니다.
3. **타입 안정성**: 모든 데이터에 타입을 명시하고 any 사용을 지양합니다.
4. **재사용성**: 공통으로 사용되는 코드는 shared 레이어에 배치합니다.
5. **테스트 가능성**: 순수 함수로 작성하여 테스트하기 쉽게 만듭니다.

### 단계별 진행 방법
1. 각 단계를 순차적으로 진행합니다.
2. 각 단계의 체크포인트를 모두 완료한 후 다음 단계로 진행합니다.
3. 중간 중간 코드 리뷰를 통해 개선점을 찾습니다.
4. 문서화를 통해 학습한 내용을 정리합니다.

---

## 🔍 참고 자료

### FSD (Feature-Sliced Design)
- 공식 문서: https://feature-sliced.design/
- 레이어 구조: app > pages > widgets > features > entities > shared

### TanstackQuery
- 공식 문서: https://tanstack.com/query/latest
- React Query 가이드: https://tanstack.com/query/latest/docs/react/overview

### 상태 관리 라이브러리
- Context API: React 공식 문서
- Zustand: https://zustand-demo.pmnd.rs/
- Jotai: https://jotai.org/

---

## ✅ 최종 검증 항목

### 코드 품질
- [ ] TypeScript 타입이 모든 곳에 적용되었는가?
- [ ] 컴포넌트가 작고 단일 책임을 가지는가?
- [ ] Props Drilling이 최소화되었는가?
- [ ] 코드가 읽기 쉽고 유지보수하기 쉬운가?

### 아키텍처
- [ ] 관심사가 적절히 분리되었는가?
- [ ] 각 레이어의 역할이 명확한가?
- [ ] 의존성 방향이 올바른가? (상위 레이어가 하위 레이어에 의존)

### 기능
- [ ] 모든 기능이 정상적으로 동작하는가?
- [ ] 에러 처리가 적절히 구현되었는가?
- [ ] 로딩 상태가 적절히 표시되는가?
- [ ] 사용자 경험이 개선되었는가?

---

**작성일**: 2025-12-08
**프로젝트**: front_7th_chapter3-3

